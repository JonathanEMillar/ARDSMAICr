#' @title Information adjacency matrix
#' @description Creates an adjacency matrix of shared information content/contribution between
#'     studies.
#' @param data Data frame in the format of `ARDSMAICR::data_genes`
#' @param contribution Return the information contribution -- Default = FALSE
#' @param unique Include information for genes uniquely identified by a study -- Default = TRUE
#' @param as_list Option to return an adjacency list -- Default = FALSE
#' @return A matrix with the dimensions n studies x n studies. Where the cells represent the summed
#'     scores of genes shared between studies. Direction is maintained, columns to rows represents
#'     the information in the column shared with the row. The return may be specified as the
#'     information content - all gene scores regardless of their contribution to the MAIC score - or
#'     the information contribution - only gene scores where the study contributes to the MAIC score
#'     for that gene. The option to include or remove information content/contribution generated by
#'     a study uniquely is available.
#' @details
#' Input columns for `data_genes` should be (this is the standard output of the MAIC algorithm):
#' * `gene` - HGNC gene symbol - chr
#' * 1...
#' * `uID` - Study unique identifier. Column contains study specific gene score - dbl
#' * n...
#' * `maic_score` - MAIC score for gene - dbl
#' * `contributors` - Studies contributing to MAIC score by method - chr
#' @md
#' @examples
#' \dontrun{
#' if(interactive()){
#'  inf_agj_matrix(ARDSMAICR::data_genes, contribution = TRUE, unique = FALSE)
#'  }
#' }
#' @rdname inf_adj_matrix
#' @export
#' @importFrom dplyr select mutate na_if filter summarize rename
#' @importFrom tibble column_to_rownames tibble
#' @importFrom utils combn
#' @importFrom rlang sym
#' @importFrom tidyr spread

inf_adj_matrix <- function(data, contribution = FALSE, unique = TRUE, as_list = FALSE) {

  ## set contribution behaviour - if TRUE will retain only the gene scores where the study is a
  ## contributor to the maic score. if FALSE will retain all gene scores i.e, the information
  ## content.

  if (contribution == TRUE) {

    df <- data |>
      tidyr::separate(.data$contributors, c("study_1", "study_2", "study_3", "study_4", "study_5"), "\\,", fill = "right") |>
      dplyr::mutate_at(c("study_1", "study_2", "study_3"), ~ stringr::str_remove(.x, "^(.*?:)")) |>
      dplyr::mutate_at(c("study_1", "study_2", "study_3"), ~ stringr::str_trim(.x)) |>
      dplyr::mutate_at(c("study_1", "study_2", "study_3"), ~ tidyr::replace_na(., "")) |>
      dplyr::select(-.data$maic_score) |>
      dplyr::rowwise() |>
      dplyr::mutate(dplyr::across(tidyselect::where(is.numeric), ~ ifelse((
        dplyr::cur_column() %in% study_1 | dplyr::cur_column() %in% study_2 | dplyr::cur_column() %in% study_3 | dplyr::cur_column() %in% study_4 | dplyr::cur_column() %in% study_5),
        ., NA))) |>
      dplyr::ungroup() |>
      dplyr::select(-c(.data$study_1, .data$study_2, .data$study_3, .data$study_4, .data$study_5)) |>
      tibble::column_to_rownames(var = "gene")

  } else {

    df <- data |>
      dplyr::select(-c(.data$maic_score, .data$contributors)) |>
      dplyr::mutate(across(where(is.numeric), ~ dplyr::na_if(., 0))) |>
      tibble::column_to_rownames(var = "gene")

  }

  ## directional sum of all pairwise combinations

  col_comb <- c(utils::combn(names(df), 2, simplify = FALSE), lapply(utils::combn(names(df), 2, simplify = FALSE), rev))

  col_sums_list <- lapply(col_comb, function(cols) {
    df |>
      dplyr::filter(!is.na(eval(sym(cols[2])))) |>
      dplyr::summarize(sum_col1 = sum(eval(rlang::sym(cols[1])), na.rm = TRUE)) |>
      dplyr::mutate(col1 = cols[1], col2 = cols[2])
  })

  col_sums_df <- do.call(rbind, col_sums_list) |>
    dplyr::rename(From = .data$col1, To = .data$col2, Value = .data$sum_col1) |>
    dplyr::filter(.data$Value > 0)

  ## set unique behaviour - if TRUE will include the contribution of genes which are identified
  ## by a single study. if false will remove this self-referencing information.

  if (unique == TRUE) {

    find_col <- function(df, col) {
      df_subset <- df[!is.na(df[, col]) & rowSums(!is.na(df[, names(df) != col])) == 0, ]
      result_col <- df_subset[, col]
      return(result_col)
    }

    unique_genes_sums <- sapply(colnames(df), function(col_name) {
      sum(find_col(df, col_name))
    })

    unique_genes_sums_df <- tibble::tibble(From = colnames(df), To = colnames(df), Value = unique_genes_sums)

    overall <- bind_rows(col_sums_df, unique_genes_sums_df)

    output <- tidyr::spread(overall, .data$From, .data$Value) |>
      tibble::column_to_rownames(var = "To") |>
      as.matrix()

  } else {

    overall <- col_sums_df

    output <- tidyr::spread(overall, .data$From, .data$Value) |>
      tibble::column_to_rownames(var = "To") |>
      as.matrix()

  }

  output[is.na(output)] <- 0

  ## option for adjacency list

  if (as_list == TRUE){

    adj_list <- output |>
      tibble::as_tibble(rownames = "To") |>
      tidyr::gather(key = "From", value = "Value", -.data$To)

    return(adj_list)

  } else {

    return(output)

  }
}

#' @title Normalise gene scores
#' @description Normalises genes scores to account for the length of the input list.
#' @param data Data frame in the format of `ARDSMAICR::data_genes`
#' @return A data frame
#' @details
#' Normalised by dividing the gene scores for each list by the length of the list.
#' Input columns for `data_genes` should be (this is the standard output of the MAIC algorithm):
#' * `gene` - HGNC gene symbol - chr
#' * 1...
#' * `uID` - Study unique identifier. Column contains study specific gene score - dbl
#' * n...
#' * `maic_score` - MAIC score for gene - dbl
#' * `contributors` - Studies contributing to MAIC score by method - chr
#' @md
#' @examples
#' \dontrun{
#' if(interactive()){
#'  normalised_info_content_matrix <- ARDSMAICR::data_genes |>
#'  normalise_gene_scores() |>
#'  inf_adj_matrix(unique = FALSE)
#'  }
#' }
#' @rdname normalise_gene_scores
#' @export
#' @importFrom dplyr mutate

normalise_gene_scores <- function(data) {

  df <- data |>
    dplyr::mutate(across(where(is.numeric) & !.data$maic_score, ~ ./sum(. != 0)))

  return(df)

}



